# 🐳 Criti.AI Docker 배포 및 관리 

## 📁 새로운 파일 구조

```
criti-ai/
├── scripts/                        # 🚀 모든 실행 스크립트
│   ├── deploy-micro-auto.sh          # Oracle Cloud 완전 자동화 배포
│   ├── monitor-micro.sh              # 자동 모니터링 및 복구
│   ├── optimize-micro.sh             # 서버 최적화 스크립트
│   └── start-system.bat              # Windows 개발 환경 시작
├── config/                         # ⚙️ 모든 설정 파일
│   ├── docker/                       # 🐳 Docker 관련 설정
│   │   ├── docker-compose.yml        # 로컬 개발용
│   │   └── docker-compose.micro.yml  # Oracle Micro 프로덕션용
│   ├── nginx.conf                # Nginx 기본 설정
│   └── nginx.micro.conf          # Nginx Micro 최적화 설정
├── backend/                    # 🔧 백엔드 API
│   └── .env                     # 백엔드 환경변수 (GEMINI_API_KEY 등)
├── challenge-web/              # 🌐 챌린지 웹앱
│   └── .env                     # 웹앱 환경변수 (VITE_BACKEND_URL 등)
├── frontend/                   # 🔗 크롬 확장
│   └── .env                     # 확장 환경변수 (EXTENSION_ID 등)
└── shared/                     # 📦 공통 타입 정의
```

---

## 🚀 1. scripts/deploy-micro-auto.sh

### **역할: Oracle Cloud 완전 자동화 배포**

```bash
cd scripts
./deploy-micro-auto.sh
```

#### **📋 명령어 상세 분석:**

- `./deploy-micro-auto.sh`: 현재 디렉토리의 실행 가능한 쉘 스크립트 실행
- 실행 전 권한 설정 필요: `chmod +x deploy-micro-auto.sh`

#### **📋 수행 작업 (10단계)**

1. **사전 환경 확인**: Oracle Cloud 인스턴스, 메모리, 디스크 확인
2. **시스템 최적화**: 2GB Swap 생성, 커널 파라미터 조정
3. **Docker 설치**: Docker + Docker Compose 설치 및 메모리 최적화
4. **방화벽 설정**: ufw로 22, 80, 443 포트만 개방
5. **프로젝트 코드 준비**: Git clone 또는 최신 코드 pull
6. **환경변수 설정**: Gemini API 키 입력 및 .env 파일 생성
7. **서비스 빌드**: `../config/docker/docker-compose.micro.yml` 사용
8. **배포 상태 확인**: 컨테이너, 헬스체크, 메모리 확인
9. **모니터링 설정**: systemd 서비스로 자동 재시작 등록
10. **최종 정보 출력**: 접속 URL, 관리 명령어 안내

#### **⏰ 소요시간: 10-15분**

#### **🎯 사용 시기: Oracle Cloud 최초 배포 시**

#### **내부 사용 Docker 명령어들:**

```bash
# 컨테이너 정리
docker-compose -f ../config/docker/docker-compose.micro.yml down
# ↑ docker-compose: Docker Compose 실행
# ↑ -f: --file, 사용할 compose 파일 지정
# ↑ down: 모든 컨테이너/네트워크 정지 및 제거

# 이미지 빌드
docker-compose -f ../config/docker/docker-compose.micro.yml build
# ↑ build: Dockerfile을 사용해 이미지 빌드

# 서비스 시작 (백그라운드)
docker-compose -f ../config/docker/docker-compose.micro.yml up -d
# ↑ up: 컨테이너 생성 및 시작
# ↑ -d: --detach, 백그라운드에서 실행 (터미널 차단하지 않음)
```

---

## 🐳 2. config/docker/docker-compose.yml

### **역할: 로컬 개발 환경용**

```bash
# 루트 디렉토리에서 실행
npm run docker:dev
# 또는
docker-compose -f config/docker/docker-compose.yml up -d
```

#### **📋 명령어 상세:**

```bash
docker-compose -f config/docker/docker-compose.yml up -d
```

- `docker-compose`: Docker Compose CLI 도구
- `-f config/docker/docker-compose.yml`: 특정 파일 지정 (기본값: ./docker-compose.yml)
- `up`: 정의된 서비스들을 생성하고 시작
- `-d`: detached 모드 (백그라운드 실행, 로그 출력 안함)

#### **서비스 구성**

```yaml
services:
  redis: # 캐시 서버 (개발용 설정)
  backend: # API 서버 (포트 3001 노출)
  frontend: # 프론트엔드 개발 서버 (포트 5173 노출)
```

#### **특징**

- 🖥️ **개발 전용**: 모든 포트 직접 노출, 상세한 로그
- 🔧 **디버깅 편의**: 컨테이너 재시작 시 코드 변경사항 자동 반영
- 💾 **메모리 제한 없음**: 개발 편의성 우선
- 🌐 **프론트엔드 포함**: React 개발 서버 포함

#### **🎯 사용 시기**

- 로컬에서 전체 시스템 개발할 때
- 프론트엔드와 백엔드 동시 테스트할 때
- 데이터베이스 스키마 변경 테스트할 때

#### **관련 명령어들:**

```bash
# 서비스 시작
npm run docker:dev
docker-compose -f config/docker/docker-compose.yml up -d

# 로그 확인 (실시간)
npm run docker:logs
docker-compose -f config/docker/docker-compose.yml logs -f
# ↑ logs: 컨테이너 로그 출력
# ↑ -f: --follow, 실시간 로그 스트림 (Ctrl+C로 중단)

# 서비스 중지
npm run docker:stop
docker-compose -f config/docker/docker-compose.yml down
# ↑ down: 컨테이너 정지 및 제거, 네트워크도 제거

# 특정 서비스만 재시작
docker-compose -f config/docker/docker-compose.yml restart backend
# ↑ restart: 특정 서비스만 재시작 (이미지 재빌드 안함)
```

---

## ⚡ 3. config/docker/docker-compose.micro.yml

### **역할: Oracle Micro 인스턴스 최적화**

```bash
# 루트 디렉토리에서 실행
npm run docker:micro
# 또는
docker-compose -f config/docker/docker-compose.micro.yml up -d
```

#### **📋 명령어 상세 분석:**

```bash
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
```

- `docker-compose`: Docker Compose CLI
- `-f config/docker/docker-compose.micro.yml`: Micro 최적화 설정 파일 사용
- `up -d`: 백그라운드에서 서비스 시작
- `--no-deps`: 의존성 서비스(redis, nginx) 건드리지 않고 backend만 업데이트
- `backend`: 특정 서비스만 대상으로 지정

#### **서비스 구성**

```yaml
services:
  backend: # 메모리 제한 200MB, CPU 0.7 코어
  redis: # 메모리 제한 80MB, 최소 설정
  nginx: # 메모리 제한 50MB, 리버스 프록시
```

#### **특징**

- ⚡ **극한 최적화**: 총 메모리 사용량 < 400MB
- 🎯 **프로덕션 전용**: 보안, 성능, 안정성 우선
- 🚫 **프론트엔드 제외**: Vercel 별도 배포 전제
- 📊 **리소스 모니터링**: 헬스체크, 메모리/CPU 제한

#### **주요 최적화 설정:**

```yaml
# Node.js 메모리 제한 (backend 서비스)
environment:
  - NODE_OPTIONS=--max-old-space-size=128 # 128MB로 제한

# Docker 리소스 제한
mem_limit: 200m # 메모리 최대 200MB
mem_reservation: 150m # 메모리 보장 150MB
cpus: 0.7 # CPU 0.7 코어로 제한

# Redis 최적화
command: >
  redis-server 
  --maxmemory 64mb                # 최대 메모리 64MB
  --maxmemory-policy allkeys-lru  # 메모리 초과시 LRU 정책
  --save ""                       # 디스크 저장 비활성화
  --appendonly no                 # AOF 비활성화
```

#### **🎯 사용 시기**

- Oracle Cloud Micro 인스턴스 배포
- 메모리 1GB 이하 서버 운영
- 프로덕션 환경 운영

#### **핵심 관리 명령어들:**

```bash
# 전체 시스템 시작
npm run docker:micro
docker-compose -f config/docker/docker-compose.micro.yml up -d

# 백엔드만 무중단 업데이트 ⭐ (가장 많이 사용)
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
# ↑ 가장 중요한 명령어! 코드 수정 후 5초 다운타임으로 업데이트

# 특정 서비스 재시작
docker-compose -f config/docker/docker-compose.micro.yml restart backend
# ↑ restart: 컨테이너 재시작 (환경변수 변경 후 사용)

# 전체 시스템 중지
npm run docker:micro:stop
docker-compose -f config/docker/docker-compose.micro.yml down
# ↑ down: 모든 컨테이너와 네트워크 제거

# 상태 확인
docker-compose -f config/docker/docker-compose.micro.yml ps
# ↑ ps: 현재 실행 중인 컨테이너 상태 확인

# 실시간 로그
npm run docker:micro:logs
docker-compose -f config/docker/docker-compose.micro.yml logs -f backend
# ↑ 특정 서비스의 실시간 로그만 확인
```

---

## 🖥️ 4. scripts/start-system.bat

### **역할: Windows 로컬 개발 자동화**

```bash
# Windows에서
cd scripts
start-system.bat
```

#### **📋 수행 작업**

1. **Prisma 스키마 업데이트**: `db:push`, `db:generate`
2. **시스템 테스트 실행**: `test:system`
3. **개발 서버 시작 안내**: 실행 방법 출력

#### **특징**

- 🪟 **Windows 전용**: .bat 확장자, Windows 경로 사용
- 🧪 **테스트 우선**: 시스템 테스트 후 수동 서버 시작 안내
- 📚 **교육적**: 자동 실행보다 단계별 학습 지원

#### **🎯 사용 시기**

- Windows에서 로컬 개발 시작할 때
- 데이터베이스 스키마 변경 후
- 팀원 온보딩 시 개발 환경 설정

---

## 🔧 5. scripts/optimize-micro.sh

### **역할: Oracle Micro 서버 시스템 최적화**

```bash
cd scripts
chmod +x optimize-micro.sh
./optimize-micro.sh
```

#### **📋 최적화 작업 (14단계)**

1. **시스템 정보 수집**: `free`, `df`, `nproc` 명령으로 리소스 확인
2. **시스템 업데이트**: `apt update && apt upgrade -y`
3. **Swap 파일 생성**: `fallocate -l 2G /swapfile` (메모리 2배)
4. **커널 파라미터 최적화**: `sysctl.conf` 메모리 및 네트워크 튜닝
5. **불필요한 서비스 제거**: snapd, bluetooth, cups 등 비활성화
6. **Docker 설치**: 메모리 효율적인 daemon.json 설정
7. **Docker Compose 설치**: 최신 버전 v2.20.0
8. **방화벽 강화**: ufw로 필수 포트만 허용
9. **로그 관리**: journald 로그 크기 제한 (100MB)
10. **크론 작업**: 자동 정리 작업 등록
11. **모니터링 도구**: 리소스 체크 스크립트 생성
12. **편의 스크립트**: deploy.sh, monitor.sh 생성
13. **시스템 정리**: 캐시 및 임시 파일 제거
14. **재부팅 권장**: 모든 설정 적용

#### **특징**

- 🔥 **극한 최적화**: 1GB RAM에서 최대 성능 확보
- 🛡️ **보안 강화**: 최소 권한 원칙, 불필요한 서비스 제거
- 📊 **모니터링 준비**: 자동화된 관리 도구 설치
- 🔄 **지속적 관리**: 정기 정리 및 유지보수 자동화

#### **🎯 사용 시기**

- 새로운 Oracle Cloud 인스턴스 설정 시
- 서버 성능 저하 문제 해결 시
- 메모리 부족 현상 발생 시

---

## 📊 6. scripts/monitor-micro.sh

### **역할: 자동 모니터링 및 장애 복구**

```bash
cd scripts
chmod +x monitor-micro.sh

# 사용법
./monitor-micro.sh                   # 모니터링 시작 (무한 루프)
./monitor-micro.sh --status          # 현재 상태만 확인
./monitor-micro.sh --restart         # 수동 재시작
./monitor-micro.sh --cleanup         # Docker 정리
./monitor-micro.sh --help            # 도움말
```

#### **📋 명령어 상세 분석:**

```bash
./monitor-micro.sh --status
```

- `--status`: 현재 시스템 상태 확인 옵션
  - 메모리 사용률 체크 (`free` 명령어 사용)
  - 컨테이너 상태 확인 (`docker-compose ps`)
  - API 헬스체크 (`curl http://localhost:3001/health`)

```bash
./monitor-micro.sh --restart
```

- `--restart`: 수동 재시작 옵션
  - 현재 컨테이너 정리 (`docker-compose down`)
  - 시스템 캐시 정리 (`sync && echo 3 > /proc/sys/vm/drop_caches`)
  - 서비스 재시작 (`docker-compose up -d`)

#### **📋 모니터링 기능**

1. **메모리 감시**: 90% 초과 시 자동 재시작
2. **서비스 감시**: 컨테이너 다운 감지 즉시 복구
3. **API 헬스체크**: 3회 연속 실패 시 재시작
4. **재시작 제한**: 1시간당 최대 3회 (무한 루프 방지)
5. **Docker 정리**: 매주 일요일 03:00 자동 정리
6. **로그 기록**: 모든 이벤트 타임스탬프와 함께 기록

#### **특징**

- 🔄 **자동 운영**: 지속적인 무인 모니터링
- 🚨 **자동 복구**: 장애 감지 즉시 복구 (평균 30초)
- 📝 **상세 로깅**: 모든 상태 변화 기록 (`monitor.log`)
- 🛡️ **과부하 방지**: 재시작 횟수 제한으로 시스템 보호

#### **🎯 사용 시기**

- 프로덕션 서버 운영 시 (systemd 서비스로 등록)
- 메모리 부족으로 인한 장애가 빈번할 때
- 무인 운영이 필요한 환경

#### **systemd 서비스 등록 (자동 시작):**

```bash
# 서비스 파일 생성 (deploy-micro-auto.sh에서 자동 생성됨)
sudo tee /etc/systemd/system/criti-ai-monitor.service << EOF
[Unit]
Description=Criti.AI Monitoring Service
After=docker.service

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/criti-ai/scripts
ExecStart=/home/ubuntu/criti-ai/scripts/monitor-micro.sh
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 서비스 등록 및 시작
sudo systemctl daemon-reload
sudo systemctl enable criti-ai-monitor
sudo systemctl start criti-ai-monitor

# 상태 확인
sudo systemctl status criti-ai-monitor
```

---

## 📊 Docker 명령어 완벽 비교표

| 명령어                                                                             | 용도              | 다운타임 | 이미지 재빌드  | 의존성 체크 | 사용 시기        |
| ---------------------------------------------------------------------------------- | ----------------- | -------- | -------------- | ----------- | ---------------- |
| `scripts/deploy-micro-auto.sh`                                                     | 완전 자동 배포    | 15분     | ✅ 전체        | ✅ 전체     | **최초 설치**    |
| `npm run docker:dev`                                                               | 개발 환경 시작    | 1-2분    | ✅ 변경분      | ✅ 전체     | **로컬 개발**    |
| `npm run docker:micro`                                                             | 프로덕션 시작     | 30-60초  | ✅ 변경분      | ✅ 전체     | **서버 시작**    |
| `docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend` | 백엔드만 업데이트 | **5초**  | ✅ Backend만   | ❌ 무시     | **코드 수정** ⭐ |
| `docker-compose -f config/docker/docker-compose.micro.yml restart backend`         | 백엔드만 재시작   | 10초     | ❌ 기존 이미지 | ❌ 재시작만 | **설정 변경**    |
| `scripts/monitor-micro.sh --restart`                                               | 모니터링 재시작   | 30초     | ❌ 기존 이미지 | ❌ 재시작만 | **장애 복구**    |

---

## 🎯 실전 시나리오별 완벽 가이드

### **📝 시나리오 1: 새 서버에 처음 배포**

```bash
# Oracle Cloud Ubuntu 20.04 인스턴스에서
git clone https://github.com/your-repo/criti-ai.git
cd criti-ai/scripts
chmod +x *.sh
./deploy-micro-auto.sh
```

**⏰ 결과**: 15분 후 완전한 서비스 운영 가능
**🔍 확인**: `curl http://your-server-ip:3001/health`

---

### **📝 시나리오 2: 코드 수정 후 무중단 배포 ⭐**

```bash
# 서버에서 (가장 자주 사용하는 시나리오)
git pull origin main
cd shared && npm run build && cd ..

# 백엔드만 5초 다운타임으로 업데이트
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
# ↑ docker-compose: Docker Compose 실행
# ↑ -f config/docker/docker-compose.micro.yml: 특정 설정 파일 지정
# ↑ up -d: 백그라운드에서 컨테이너 시작
# ↑ --no-deps: 의존성(redis, nginx) 건드리지 않음
# ↑ backend: 특정 서비스만 대상

# 상태 확인
curl http://localhost:3001/health
cd scripts && ./monitor-micro.sh --status
```

**⏰ 다운타임**: 5초
**🎯 언제**: 코드만 수정했을 때 (API 로직, 버그 수정 등)

---

### **📝 시나리오 3: 환경변수 변경 후 적용**

```bash
# backend/.env 파일 수정 후
nano backend/.env

# 환경변수는 컨테이너 재시작으로만 적용됨 (재빌드 불필요)
docker-compose -f config/docker/docker-compose.micro.yml restart backend
# ↑ restart: 기존 이미지를 사용해 컨테이너만 재시작
# ↑ 환경변수, 볼륨 마운트 등 설정 변경사항 적용

# 또는 모니터링 스크립트 사용
cd scripts && ./monitor-micro.sh --restart
```

**⏰ 다운타임**: 10초
**🎯 언제**: .env 파일 수정, 환경변수 변경 시

---

### **📝 시나리오 4: Docker 설정 변경**

```bash
# docker-compose.micro.yml 또는 Dockerfile 수정 후
nano config/docker/docker-compose.micro.yml

# 설정 변경 시 완전 재빌드 필요
docker-compose -f config/docker/docker-compose.micro.yml down
# ↑ down: 모든 컨테이너, 네트워크, 볼륨 제거

docker-compose -f config/docker/docker-compose.micro.yml build --no-cache
# ↑ build: 이미지 빌드
# ↑ --no-cache: 캐시 사용 안함 (완전 새로 빌드)

docker-compose -f config/docker/docker-compose.micro.yml up -d
# ↑ up -d: 빌드된 이미지로 컨테이너 시작
```

**⏰ 다운타임**: 2-5분
**🎯 언제**: Docker 설정, 포트, 볼륨, 네트워크 변경 시

---

### **📝 시나리오 5: 로컬에서 개발 시작**

```bash
# Windows
cd scripts
start-system.bat

# Linux/Mac 수동 방법
cd backend && npm run dev          # 터미널 1: 백엔드 서버
cd challenge-web && npm run dev    # 터미널 2: 챌린지 웹앱
cd frontend && npm run dev          # 터미널 3: 크롬 확장 개발

# 또는 Docker로 통합 실행
npm run docker:dev
# ↑ config/docker/docker-compose.yml 사용
# ↑ 개발용 설정으로 모든 서비스 시작
```

---

### **📝 시나리오 6: 서버 최적화 및 성능 문제 해결**

```bash
# 메모리 부족, 성능 저하 시
cd scripts
./optimize-micro.sh
# ↑ 시스템 최적화, Swap 생성, 불필요한 서비스 제거

# 최적화 후 재부팅 (권장)
sudo reboot

# 재부팅 후 서비스 시작 확인
cd scripts && ./monitor-micro.sh --status
```

---

### **📝 시나리오 7: 급작스러운 장애 대응**

```bash
# 1단계: 즉시 상태 확인
cd scripts && ./monitor-micro.sh --status

# 2단계: 문제 있으면 즉시 재시작
./monitor-micro.sh --restart

# 3단계: 메모리/디스크 정리
./monitor-micro.sh --cleanup
# ↑ 사용하지 않는 Docker 이미지, 컨테이너, 볼륨 정리

# 4단계: 로그 확인
docker-compose -f ../config/docker/docker-compose.micro.yml logs -f backend
# ↑ logs -f: 실시간 로그 스트림 (Ctrl+C로 종료)

# 5단계: 최후의 수단 - 완전 초기화
cd scripts && ./deploy-micro-auto.sh
```

---

## 💡 Pro Tips & Best Practices

### **🚀 무중단 배포 완벽 가이드**

```bash
# 1단계: 안전한 코드 업데이트
git stash                                    # 로컬 변경사항 임시 저장
git pull origin main                         # 최신 코드 가져오기
cd shared && npm run build && cd ..          # 공통 타입 빌드

# 2단계: 백엔드만 업데이트 (가장 안전한 방법) ⭐
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend

# 3단계: 헬스체크 (30초 대기 후)
sleep 30
curl -f http://localhost:3001/health || echo "❌ 헬스체크 실패"

# 4단계: 문제 발생 시 즉시 롤백
git log --oneline -5                         # 최근 커밋 확인
git reset --hard HEAD~1                     # 이전 커밋으로 롤백
docker-compose -f config/docker/docker-compose.micro.yml restart backend
```

### **⚡ Docker 명령어 단축키 설정**

```bash
# ~/.bashrc 또는 ~/.zshrc에 추가
alias dc-micro='docker-compose -f config/docker/docker-compose.micro.yml'
alias dc-dev='docker-compose -f config/docker/docker-compose.yml'

# 사용 예시
dc-micro up -d --no-deps backend    # 백엔드만 업데이트
dc-micro logs -f backend             # 백엔드 로그 확인
dc-micro restart backend             # 백엔드 재시작
dc-dev up -d                         # 개발 환경 시작
```

### **📊 모니터링 및 진단 완벽 가이드**

```bash
# 실시간 상태 대시보드
watch -n 1 'cd scripts && ./monitor-micro.sh --status'
# ↑ watch -n 1: 1초마다 명령어 반복 실행
# ↑ Ctrl+C로 중단

# 리소스 사용량 실시간 모니터링
docker stats
# ↑ 모든 컨테이너의 CPU, 메모리, 네트워크 실시간 표시

# 특정 컨테이너 상세 정보
docker inspect criti-ai-backend | jq '.[]|{Status:.State.Status,Memory:.HostConfig.Memory}'
# ↑ jq: JSON 파서 (설치 필요: sudo apt install jq)

# 메모리 사용률 세부 분석
free -h && echo "---" && docker stats --no-stream

# 디스크 사용량 확인
df -h / && echo "---" && docker system df
# ↑ 시스템 디스크 vs Docker 디스크 사용량 비교
```

---

## 🔧 문제 해결 완벽 가이드

### **❌ 메모리 부족 오류 (가장 흔한 문제)**

```bash
# 증상 확인
free -h                              # 메모리 상태
docker stats --no-stream            # 컨테이너 메모리 사용량

# 해결 방법 1: 즉시 메모리 정리
cd scripts && ./monitor-micro.sh --cleanup
sync && echo 3 | sudo tee /proc/sys/vm/drop_caches  # 시스템 캐시 정리

# 해결 방법 2: 서비스 재시작
./monitor-micro.sh --restart

# 해결 방법 3: 근본적 최적화
./optimize-micro.sh                  # 시스템 최적화
sudo reboot                          # 재부팅으로 메모리 완전 정리
```

### **❌ 컨테이너 시작 실패**

```bash
# 1단계: 상세 로그 확인
docker-compose -f config/docker/docker-compose.micro.yml logs backend
# ↑ 에러 메시지 확인

# 2단계: 환경변수 확인
cat backend/.env | grep GEMINI_API_KEY    # API 키 확인
docker-compose -f config/docker/docker-compose.micro.yml config
# ↑ 최종 설정값 확인

# 3단계: 포트 충돌 확인
sudo netstat -tlnp | grep :3001           # 포트 3001 사용 프로세스 확인
sudo lsof -i :3001                        # 포트 점유 프로세스 상세 정보

# 4단계: 완전 재빌드
docker-compose -f config/docker/docker-compose.micro.yml down -v
# ↑ -v: 볼륨도 함께 제거
docker-compose -f config/docker/docker-compose.micro.yml build --no-cache
docker-compose -f config/docker/docker-compose.micro.yml up -d
```

### **❌ API 응답 없음 (502, 503 오류)**

```bash
# 1단계: 직접 헬스체크
curl -v http://localhost:3001/health       # 상세 HTTP 응답 확인
curl -v http://your-server-ip:3001/health  # 외부 접속 확인

# 2단계: 네트워크 및 방화벽 확인
sudo ufw status                            # 방화벽 규칙 확인
docker network ls                          # Docker 네트워크 확인
docker-compose -f config/docker/docker-compose.micro.yml ps  # 컨테이너 상태

# 3단계: Nginx 프록시 확인
docker-compose -f config/docker/docker-compose.micro.yml logs nginx
curl -v http://localhost:80               # Nginx 직접 접속

# 4단계: 백엔드 직접 접속 테스트
docker exec -it criti-ai-backend curl localhost:3001/health
# ↑ 컨테이너 내부에서 직접 API 테스트
```

### **❌ Docker Compose 파일 문법 오류**

```bash
# YAML 문법 검사
docker-compose -f config/docker/docker-compose.micro.yml config
# ↑ 설정 파일 검증 및 최종 값 출력

# 일반적인 YAML 문법 오류들
# 1. 들여쓰기 (탭 대신 스페이스 2개)
# 2. 콜론 뒤 공백 필수 (key: value)
# 3. 리스트 항목 앞 하이픈+공백 (- item)
# 4. 따옴표 처리 (특수문자 포함 시 "value")
```

---

## 🎯 핵심 포인트


1. **일상 운영 (90%)**:
   ```bash
   docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
   ```
2. **상태 확인**:
   ```bash
   cd scripts && ./monitor-micro.sh --status
   ```
3. **긴급 복구**:
   ```bash
   cd scripts && ./monitor-micro.sh --restart
   ```
4. **최초 설치**:
   ```bash
   cd scripts && ./deploy-micro-auto.sh
   ```
5. **개발 환경**:
   ```bash
   npm run docker:dev
   ```

### **⚡ 핵심 운영**

- **무중단 배포**: `--no-deps` 옵션으로 의존성 서비스 건드리지 않기
- **메모리 최적화**: 항상 메모리 사용률 90% 이하 유지
- **자동화 우선**: 수동 작업보다 스크립트와 모니터링 활용
- **단계적 접근**: 문제 발생 시 재시작 → 정리 → 재빌드 → 완전 초기화 순서

### **🔮 다음 단계 권장사항**

1. **모니터링 설정**: `monitor-micro.sh`를 systemd 서비스로 등록
2. **백업 전략**: 데이터베이스와 설정 파일 정기 백업
3. **로그 관리**: 로그 로테이션과 중앙 집중식 로깅 구축
4. **CI/CD 파이프라인**: GitHub Actions와 연동한 자동 배포

---