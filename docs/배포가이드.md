# Criti.AI Docker 배포 및 관리

## 새로운 파일 구조

```
criti-ai/
├── scripts/                        # 모든 실행 스크립트
│   ├── deploy-micro-auto.sh          # Oracle Cloud 완전 자동화 배포
│   ├── monitor-micro.sh              # 자동 모니터링 및 복구
│   ├── optimize-micro.sh             # 서버 최적화 스크립트
│   └── start-system.bat              # Windows 개발 환경 시작
├── config/                         # 모든 설정 파일
│   ├── docker/                       # Docker 관련 설정
│   │   ├── docker-compose.yml        # 로컬 개발용
│   │   └── docker-compose.micro.yml  # Oracle Micro 프로덕션용
│   ├── nginx.conf                # Nginx 기본 설정
│   └── nginx.micro.conf          # Nginx Micro 최적화 설정
├── backend/                    # 백엔드 API
│   └── .env                     # 백엔드 환경변수 (GEMINI_API_KEY 등)
├── challenge-web/              # 챌린지 웹앱
│   └── .env                     # 웹앱 환경변수 (VITE_BACKEND_URL 등)
├── chrome-extension/                   # 크롬 확장
│   └── .env                     # 확장 환경변수 (EXTENSION_ID 등)
└── shared/                     # 공통 타입 정의
```

---

## 1. scripts/deploy-micro-auto.sh

### **Oracle Cloud 자동화 배포**

```bash
chmod +x ./scripts/deploy-micro-auto.sh
./scripts/deploy-micro-auto.sh
```

#### **명령어 상세**

- `./deploy-micro-auto.sh`: 현재 디렉토리의 실행 가능한 쉘 스크립트 실행
- 실행 전 권한 설정 필요: `chmod +x deploy-micro-auto.sh`

#### **수행 작업 (10단계)**

1. **사전 환경 확인**: Oracle Cloud 인스턴스, 메모리, 디스크 확인
2. **시스템 최적화**: 2GB Swap 생성, 커널 파라미터 조정
3. **Docker 설치**: Docker + Docker Compose 설치 및 메모리 최적화
4. **방화벽 설정**: ufw로 22, 80, 443 포트만 개방
5. **프로젝트 코드 준비**: Git clone 또는 최신 코드 pull
6. **환경변수 설정**: Gemini API 키 입력 및 .env 파일 생성
7. **서비스 빌드**: `../config/docker/docker-compose.micro.yml` 사용
8. **배포 상태 확인**: 컨테이너, 헬스체크, 메모리 확인
9. **모니터링 설정**: systemd 서비스로 자동 재시작 등록
10. **최종 정보 출력**: 접속 URL, 관리 명령어 안내

#### **소요시간: 10-15분**

#### **사용 시기: Oracle Cloud 최초 배포 시**

#### **내부 사용 Docker 명령어들:**

```bash
# 컨테이너 정리
docker-compose -f ../config/docker/docker-compose.micro.yml down
# ↑ docker-compose: Docker Compose 실행
# ↑ -f: --file, 사용할 compose 파일 지정
# ↑ down: 모든 컨테이너/네트워크 정지 및 제거

# 이미지 빌드
docker-compose -f ../config/docker/docker-compose.micro.yml build
# ↑ build: Dockerfile을 사용해 이미지 빌드

# 서비스 시작 (백그라운드)
docker-compose -f ../config/docker/docker-compose.micro.yml up -d
# ↑ up: 컨테이너 생성 및 시작
# ↑ -d: --detach, 백그라운드에서 실행 (터미널 차단하지 않음)
```

---

## 2. config/docker/docker-compose.yml

### **로컬 개발 환경용**

```bash
# 루트 디렉토리에서 실행
npm run docker:dev
# 또는
docker-compose -f config/docker/docker-compose.yml up -d
```

#### **명령어 상세**

```bash
docker-compose -f config/docker/docker-compose.yml up -d
```

- `docker-compose`: Docker Compose CLI 도구
- `-f config/docker/docker-compose.yml`: 특정 파일 지정 (기본값: ./docker-compose.yml)
- `up`: 정의된 서비스들을 생성하고 시작
- `-d`: detached 모드 (백그라운드 실행, 로그 출력 안함)

#### **서비스 구성**

```yaml
services:
  redis: # 캐시 서버 (개발용 설정)
  backend: # API 서버 (포트 3001 노출)
  chrome-extension: # 크롬 확장 개발 서버 (포트 5173 노출)
```

#### **특징**

- **개발 전용**: 모든 포트 직접 노출, 상세한 로그
- **디버깅 편의**: 컨테이너 재시작 시 코드 변경사항 자동 반영
- **메모리 제한 없음**: 개발 편의성 우선
- **크롬 확장 포함**: React 개발 서버 포함

#### **사용 시기**

- 로컬에서 전체 시스템 개발할 때
- 크롬 확장과 백엔드 동시 테스트할 때
- 데이터베이스 스키마 변경 테스트할 때

#### **관련 명령어들:**

```bash
# 서비스 시작
npm run docker:dev
docker-compose -f config/docker/docker-compose.yml up -d

# 로그 확인 (실시간)
npm run docker:logs
docker-compose -f config/docker/docker-compose.yml logs -f
# ↑ logs: 컨테이너 로그 출력
# ↑ -f: --follow, 실시간 로그 스트림 (Ctrl+C로 중단)

# 서비스 중지
npm run docker:stop
docker-compose -f config/docker/docker-compose.yml down
# ↑ down: 컨테이너 정지 및 제거, 네트워크도 제거

# 특정 서비스만 재시작
docker-compose -f config/docker/docker-compose.yml restart backend
# ↑ restart: 특정 서비스만 재시작 (이미지 재빌드 안함)
```

---

## 2-1. Micro 설정 로컬 테스트 및 관리 (Docker Desktop)

**Micro 인스턴스 환경 (제한된 리소스)을 로컬에서 시뮬레이션하며 개발 및 테스트하는 시나리오.**

### 1. Micro 환경 최초 실행 및 테스트 명령어

로컬 환경에서 **`docker-compose.micro.yml`**을 사용하여 Micro 인스턴스의 리소스 제약 조건을 시뮬레이션하며 시스템을 시작

````bash
# criti-ai/ (프로젝트 루트 디렉토리)에서 실행
# Micro 프로덕션 설정 파일 사용
docker-compose -f config/docker/docker-compose.micro.yml up --build -d
````
 - -f config/docker/docker-compose.micro.yml: Micro 프로덕션용 설정 파일 지정
 - up --build -d: 이미지가 없거나 변경 시 새로 빌드하며 백그라운드 실행.

### 2. 코드 수정 후 Micro 환경에 적용 (재빌드)
로컬에서 코드를 수정한 후, 해당 변경사항을 micro 설정이 적용된 컨테이너에 반영

````Bash

# 1. 수정된 서비스 이미지 재빌드 (backend)
# 'backend/Dockerfile.micro' 파일을 사용하여 이미지 새로 빌드
docker-compose -f config/docker/docker-compose.micro.yml build backend

# 2. 재빌드된 이미지로 컨테이너 재시작
# micro 환경 설정(mem_limit, cpus 등)을 유지하며 컨테이너만 업데이트
docker-compose -f config/docker/docker-compose.micro.yml up -d backend
````
 - build **backend**: backend 서비스의 Dockerfile (micro 설정이 적용된)을 사용해 이미지를 새로 빌드

 - up -d **backend**: 새로 빌드된 이미지를 사용하여 backend 컨테이너만 정지하고 다시 시작. (다른 서비스는 유지됨)

### 3. Micro 환경 서비스 중지
테스트 완료 후 서비스를 중지하고 컨테이너 제거

````Bash

# Micro 환경의 서비스 중지 및 컨테이너, 네트워크 제거
docker-compose -f config/docker/docker-compose.micro.yml down
````

---

## 3. config/docker/docker-compose.micro.yml

### **Oracle Micro 인스턴스 최적화**

```bash
# 루트 디렉토리에서 실행
npm run docker:micro
# 또는
docker-compose -f config/docker/docker-compose.micro.yml up -d
```

#### **명령어 상세**

```bash
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
```

- `docker-compose`: Docker Compose CLI
- `-f config/docker/docker-compose.micro.yml`: Micro 최적화 설정 파일 사용
- `up -d`: 백그라운드에서 서비스 시작
- `--no-deps`: 의존성 서비스(redis, nginx) 건드리지 않고 backend만 업데이트
- `backend`: 특정 서비스만 대상으로 지정

#### **서비스 구성**

```yaml
services:
  backend: # 메모리 제한 200MB, CPU 0.7 코어
  redis: # 메모리 제한 80MB, 최소 설정
  nginx: # 메모리 제한 50MB, 리버스 프록시
```

#### **특징**

- **최적화**: 총 메모리 사용량 < 400MB
- **프로덕션 전용**: 보안, 성능, 안정성 우선
- **크롬 확장 제외**: Vercel 별도 배포 전제
- **리소스 모니터링**: 헬스체크, 메모리/CPU 제한

#### **주요 최적화 설정:**

```yaml
# Node.js 메모리 제한 (backend 서비스)
environment:
  - NODE_OPTIONS=--max-old-space-size=128 # 128MB로 제한

# Docker 리소스 제한
mem_limit: 200m # 메모리 최대 200MB
mem_reservation: 150m # 메모리 보장 150MB
cpus: 0.7 # CPU 0.7 코어로 제한

# Redis 최적화
command: >
  redis-server
  --maxmemory 64mb                # 최대 메모리 64MB
  --maxmemory-policy allkeys-lru  # 메모리 초과시 LRU 정책
  --save ""                       # 디스크 저장 비활성화
  --appendonly no                 # AOF 비활성화
```

#### **사용 시기**

- Oracle Cloud Micro 인스턴스 배포
- 메모리 1GB 이하 서버 운영
- 프로덕션 환경 운영

#### **핵심 관리 명령어들**

```bash
# 전체 시스템 시작
npm run docker:micro
docker-compose -f config/docker/docker-compose.micro.yml up -d

# 백엔드만 무중단 업데이트 (가장 많이 사용)
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
# ↑ 가장 중요한 명령어! 코드 수정 후 5초 다운타임으로 업데이트

# 특정 서비스 재시작
docker-compose -f config/docker/docker-compose.micro.yml restart backend
# ↑ restart: 컨테이너 재시작 (환경변수 변경 후 사용)

# 전체 시스템 중지
npm run docker:micro:stop
docker-compose -f config/docker/docker-compose.micro.yml down
# ↑ down: 모든 컨테이너와 네트워크 제거

# 상태 확인
docker-compose -f config/docker/docker-compose.micro.yml ps
# ↑ ps: 현재 실행 중인 컨테이너 상태 확인

# 실시간 로그
npm run docker:micro:logs
docker-compose -f config/docker/docker-compose.micro.yml logs -f backend
# ↑ 특정 서비스의 실시간 로그만 확인

# 또는 개별 실행
docker exec -it criti-ai-backend npx prisma db push
# ↑ 데이터베이스 스키마 동기화

docker exec -it criti-ai-backend npx prisma generate
# ↑ Prisma 클라이언트 생성

docker exec -it criti-ai-backend sh -c "npx prisma db push && npx prisma generate"
# ↑ 한 번에 실행
```

---

## 4. scripts/optimize-micro.sh

### **Oracle Micro 서버 시스템 최적화**

```bash
cd scripts
chmod +x optimize-micro.sh
./optimize-micro.sh
```

#### **최적화 작업 (14단계)**

1. **시스템 정보 수집**: `free`, `df`, `nproc` 명령으로 리소스 확인
2. **시스템 업데이트**: `apt update && apt upgrade -y`
3. **Swap 파일 생성**: `fallocate -l 2G /swapfile` (메모리 2배)
4. **커널 파라미터 최적화**: `sysctl.conf` 메모리 및 네트워크 튜닝
5. **불필요한 서비스 제거**: snapd, bluetooth, cups 등 비활성화
6. **Docker 설치**: 메모리 효율적인 daemon.json 설정
7. **Docker Compose 설치**: 최신 버전 v2.20.0
8. **방화벽 강화**: ufw로 필수 포트만 허용
9. **로그 관리**: journald 로그 크기 제한 (100MB)
10. **크론 작업**: 자동 정리 작업 등록
11. **모니터링 도구**: 리소스 체크 스크립트 생성
12. **편의 스크립트**: deploy.sh, monitor.sh 생성
13. **시스템 정리**: 캐시 및 임시 파일 제거
14. **재부팅 권장**: 모든 설정 적용

#### **특징**

- **최적화**: 1GB RAM에서 최대 성능 확보
- **보안 강화**: 최소 권한 원칙, 불필요한 서비스 제거
- **모니터링 준비**: 자동화된 관리 도구 설치
- **지속적 관리**: 정기 정리 및 유지보수 자동화

#### **사용 시기**

- 새로운 Oracle Cloud 인스턴스 설정 시
- 서버 성능 저하 문제 해결 시
- 메모리 부족 현상 발생 시

---

## 5. scripts/monitor-micro.sh

### **역할: 자동 모니터링 및 장애 복구**

```bash
cd scripts
chmod +x monitor-micro.sh

# 사용법
./monitor-micro.sh                   # 모니터링 시작 (무한 루프)
./monitor-micro.sh --status          # 현재 상태만 확인
./monitor-micro.sh --restart         # 수동 재시작
./monitor-micro.sh --cleanup         # Docker 정리
./monitor-micro.sh --help            # 도움말
```

#### **명령어 상세 분석:**

```bash
./monitor-micro.sh --status
```

- `--status`: 현재 시스템 상태 확인 옵션
  - 메모리 사용률 체크 (`free` 명령어 사용)
  - 컨테이너 상태 확인 (`docker-compose ps`)
  - API 헬스체크 (`curl http://localhost:3001/health`)

```bash
./monitor-micro.sh --restart
```

- `--restart`: 수동 재시작 옵션
  - 현재 컨테이너 정리 (`docker-compose down`)
  - 시스템 캐시 정리 (`sync && echo 3 > /proc/sys/vm/drop_caches`)
  - 서비스 재시작 (`docker-compose up -d`)

#### **모니터링 기능**

1. **메모리 감시**: 90% 초과 시 자동 재시작
2. **서비스 감시**: 컨테이너 다운 감지 즉시 복구
3. **API 헬스체크**: 3회 연속 실패 시 재시작
4. **재시작 제한**: 1시간당 최대 3회 (무한 루프 방지)
5. **Docker 정리**: 매주 일요일 03:00 자동 정리
6. **로그 기록**: 모든 이벤트 타임스탬프와 함께 기록

#### **특징**

- **자동 운영**: 지속적인 무인 모니터링
- **자동 복구**: 장애 감지 즉시 복구 (평균 30초)
- **상세 로깅**: 모든 상태 변화 기록 (`monitor.log`)
- **과부하 방지**: 재시작 횟수 제한으로 시스템 보호

#### **사용 시기**

- 프로덕션 서버 운영 시 (systemd 서비스로 등록)
- 메모리 부족으로 인한 장애가 빈번할 때
- 무인 운영이 필요한 환경

#### **systemd 서비스 등록 (자동 시작):**

```bash
# 서비스 파일 생성 (deploy-micro-auto.sh에서 자동 생성됨)
sudo tee /etc/systemd/system/criti-ai-monitor.service << EOF
[Unit]
Description=Criti.AI Monitoring Service
After=docker.service

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/criti-ai/scripts
ExecStart=/home/ubuntu/criti-ai/scripts/monitor-micro.sh
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 서비스 등록 및 시작
sudo systemctl daemon-reload
sudo systemctl enable criti-ai-monitor
sudo systemctl start criti-ai-monitor

# 상태 확인
sudo systemctl status criti-ai-monitor
```

## 시나리오별

### **시나리오 1: 새 서버에 처음 배포**

```bash
# Oracle Cloud Ubuntu 20.04 인스턴스에서
git clone https://github.com/your-repo/criti-ai.git
cd criti-ai/scripts
chmod +x *.sh
./deploy-micro-auto.sh
```

**결과**: 15분 후 완전한 서비스 운영 가능
**확인**: `curl http://your-server-ip:3001/health`

---

### **시나리오 2: 코드 수정 후 무중단 배포**

```bash
# 서버에서 (가장 자주 사용하는 시나리오)
git pull origin main
cd shared && npm run build && cd ..

# 백엔드만 5초 다운타임으로 업데이트
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
# ↑ docker-compose: Docker Compose 실행
# ↑ -f config/docker/docker-compose.micro.yml: 특정 설정 파일 지정
# ↑ up -d: 백그라운드에서 컨테이너 시작
# ↑ --no-deps: 의존성(redis, nginx) 건드리지 않음
# ↑ backend: 특정 서비스만 대상

# 상태 확인
curl http://localhost:3001/health
cd scripts && ./monitor-micro.sh --status
```

**다운타임**: 1분
**언제**: 코드만 수정했을 때 (API 로직, 버그 수정 등)

---

### **시나리오 3: 환경변수 변경 후 적용**

```bash
# backend/.env 파일 수정 후
nano backend/.env

# 환경변수는 컨테이너 재시작으로만 적용됨 (재빌드 불필요)
docker-compose -f config/docker/docker-compose.micro.yml restart backend
# ↑ restart: 기존 이미지를 사용해 컨테이너만 재시작
# ↑ 환경변수, 볼륨 마운트 등 설정 변경사항 적용

# 또는 모니터링 스크립트 사용
cd scripts && ./monitor-micro.sh --restart
```

**다운타임**: 10초
**언제**: .env 파일 수정, 환경변수 변경 시

---

### **시나리오 4: Docker 설정 변경**

```bash
# docker-compose.micro.yml 또는 Dockerfile 수정 후
nano config/docker/docker-compose.micro.yml

# 설정 변경 시 완전 재빌드 필요
docker-compose -f config/docker/docker-compose.micro.yml down -v
# ↑ -v: 볼륨도 함께 제거

docker-compose -f config/docker/docker-compose.micro.yml build --no-cache
# ↑ build: 이미지 빌드
# ↑ --no-cache: 캐시 사용 안함 (완전 새로 빌드)

docker-compose -f config/docker/docker-compose.micro.yml up -d
# ↑ up -d: 빌드된 이미지로 컨테이너 시작
```

**다운타임**: 2-5분
**언제**: Docker 설정, 포트, 볼륨, 네트워크 변경 시

---

### **시나리오 5: 로컬에서 개발 시작**

```bash
# Windows
cd scripts
start-system.bat

# Linux/Mac 수동 방법
cd backend && npm run dev          # 터미널 1: 백엔드 서버
cd challenge-web && npm run dev    # 터미널 2: 챌린지 웹앱
cd chrome-extension && npm run dev          # 터미널 3: 크롬 확장 개발

# 또는 Docker로 통합 실행
npm run docker:dev
# ↑ config/docker/docker-compose.yml 사용
# ↑ 개발용 설정으로 모든 서비스 시작
```

---

### **시나리오 6: 서버 최적화 및 성능 문제 해결**

```bash
# 메모리 부족, 성능 저하 시
cd scripts
./optimize-micro.sh
# ↑ 시스템 최적화, Swap 생성, 불필요한 서비스 제거

# 최적화 후 재부팅 (권장)
sudo reboot

# 재부팅 후 서비스 시작 확인
cd scripts && ./monitor-micro.sh --status
```

---

### **시나리오 7: 급작스러운 장애 대응**

```bash
# 1단계: 즉시 상태 확인
cd scripts && ./monitor-micro.sh --status

# 2단계: 문제 있으면 즉시 재시작
./monitor-micro.sh --restart

# 3단계: 메모리/디스크 정리
./monitor-micro.sh --cleanup
# ↑ 사용하지 않는 Docker 이미지, 컨테이너, 볼륨 정리

# 4단계: 로그 확인
docker-compose -f ../config/docker/docker-compose.micro.yml logs -f backend
# ↑ logs -f: 실시간 로그 스트림 (Ctrl+C로 종료)

# 5단계: 최후 수단 - 완전 초기화
cd scripts && ./deploy-micro-auto.sh
```

---

## Tips

### **무중단 배포 가이드**

```bash
# 1: 안전한 코드 업데이트
git stash                                    # 로컬 변경사항 임시 저장
git pull origin main                         # 최신 코드 가져오기
cd shared && npm run build && cd ..          # 공통 타입 빌드

# 2: 백엔드만 업데이트 (가장 안전한 방법)
docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend

# 3단계: 헬스체크 (30초 대기 후)
sleep 30
curl -f http://localhost:3001/health || echo "❌ 헬스체크 실패"

# 4: 문제 발생 시 즉시 롤백
git log --oneline -5                         # 최근 커밋 확인
git reset --hard HEAD~1                     # 이전 커밋으로 롤백
docker-compose -f config/docker/docker-compose.micro.yml restart backend
```

### **모니터링 및 진단 가이드**

```bash
# 백엔드(Backend) 로그 확인 (아마 가장 궁금하실 로그):
docker logs -f criti-ai-backend

# 웹서버(Nginx) 로그 확인:
docker logs -f criti-ai-nginx

# Redis 로그 확인:
docker logs -f criti-ai-redis
```

---

## 문제 해결 가이드

### **메모리 부족 오류 (가장 흔한 문제)**

```bash
# 증상 확인
free -h                              # 메모리 상태
docker stats --no-stream            # 컨테이너 메모리 사용량

# 해결 방법 1: 즉시 메모리 정리
cd scripts && ./monitor-micro.sh --cleanup
sync && echo 3 | sudo tee /proc/sys/vm/drop_caches  # 시스템 캐시 정리

# 해결 방법 2: 서비스 재시작
./monitor-micro.sh --restart

# 해결 방법 3: 근본적 최적화
./optimize-micro.sh                  # 시스템 최적화
sudo reboot                          # 재부팅으로 메모리 완전 정리
```

### **컨테이너 시작 실패**

```bash
# 1단계: 상세 로그 확인
docker-compose -f config/docker/docker-compose.micro.yml logs backend
# ↑ 에러 메시지 확인

# 2단계: 환경변수 확인
cat backend/.env | grep GEMINI_API_KEY    # API 키 확인
docker-compose -f config/docker/docker-compose.micro.yml config
# ↑ 최종 설정값 확인

# 3단계: 포트 충돌 확인
sudo netstat -tlnp | grep :3001           # 포트 3001 사용 프로세스 확인
sudo lsof -i :3001                        # 포트 점유 프로세스 상세 정보

# 4단계: 완전 재빌드
docker-compose -f config/docker/docker-compose.micro.yml down -v
# ↑ -v: 볼륨도 함께 제거
docker-compose -f config/docker/docker-compose.micro.yml build --no-cache
docker-compose -f config/docker/docker-compose.micro.yml up -d
```

### **API 응답 없음 (502, 503 오류)**

```bash
# 1단계: 직접 헬스체크
curl -v http://localhost:3001/health       # 상세 HTTP 응답 확인
curl -v http://your-server-ip:3001/health  # 외부 접속 확인

# 2단계: 네트워크 및 방화벽 확인
sudo ufw status                            # 방화벽 규칙 확인
docker network ls                          # Docker 네트워크 확인
docker-compose -f config/docker/docker-compose.micro.yml ps  # 컨테이너 상태

# 3단계: Nginx 프록시 확인
docker-compose -f config/docker/docker-compose.micro.yml logs nginx
curl -v http://localhost:80               # Nginx 직접 접속

# 4단계: 백엔드 직접 접속 테스트
docker exec -it criti-ai-backend curl localhost:3001/health
# ↑ 컨테이너 내부에서 직접 API 테스트
```

### **Docker Compose 파일 문법 오류**

```bash
# YAML 문법 검사
docker-compose -f config/docker/docker-compose.micro.yml config
# ↑ 설정 파일 검증 및 최종 값 출력

# 일반적인 YAML 문법 오류들
# 1. 들여쓰기 (탭 대신 스페이스 2개)
# 2. 콜론 뒤 공백 필수 (key: value)
# 3. 리스트 항목 앞 하이픈+공백 (- item)
# 4. 따옴표 처리 (특수문자 포함 시 "value")
```

---

1. **일상 운영**:
   ```bash
   docker-compose -f config/docker/docker-compose.micro.yml up -d --no-deps backend
   ```
2. **상태 확인**:
   ```bash
   cd scripts && ./monitor-micro.sh --status
   ```
3. **긴급 복구**:
   ```bash
   cd scripts && ./monitor-micro.sh --restart
   ```
4. **최초 설치**:
   ```bash
   cd scripts && ./deploy-micro-auto.sh
   ```
5. **개발 환경**:
   ```bash
   npm run docker:dev
   ```
````
